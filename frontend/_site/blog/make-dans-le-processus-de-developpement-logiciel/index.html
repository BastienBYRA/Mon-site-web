<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/styles/index.css">
    <link rel="stylesheet" href="/styles/article/index.css">
    <title>Make(file) dans le processus de développement logiciel</title>
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="author" content="Bastien Byra" />
    <meta name="robots" content="index, follow">
    <meta name="description" content="Make est un outil permettant de réaliser diverses tâches via l&#39;appel d&#39;une commande. Cet article est un guide sur GNU Make, expliquant comment l&#39;utiliser, ce qu&#39;il apporte et quelles sont ses alternatives.">
    <meta name="keywords" content="Tech, Make, GNU Make, Makefile, Devops, DevSecOps">
    
    <meta property="og:image" content="../../assets/blog/GNU-Make-dans-le-developpement-logiciel/Makefile-main.png" />
    <meta property="og:description" content="Make est un outil permettant de réaliser diverses tâches via l&#39;appel d&#39;une commande. Cet article est un guide sur GNU Make, expliquant comment l&#39;utiliser, ce qu&#39;il apporte et quelles sont ses alternatives."/>
    <meta property="og:title" content="Make(file) dans le processus de développement logiciel" />
    <script src="/javascript/script.js" refferer></script>
    
    <link
			href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css"
			rel="stylesheet"
		/>

    <script data-goatcounter="https://bastienbyra.goatcounter.com/count"
        async src="//gc.zgo.at/count.js">
    </script>
    
  </head>
  <body>
    <div class="container">
      <header>
    <div class="header-main">
        <a href="/" class="header-main-link">
            Bastien Byra
        </a>
        <div class="header-right">
            <a href="/">Blog</a>
            <a href="/a-propos">A propos</a>
        </div>
        <svg id="toggle-menu-header" class="mobile-header-right" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icon-tabler-menu-2" height="44" width="44">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <line x1="4" y1="6" x2="20" y2="6" />
            <line x1="4" y1="12" x2="20" y2="12" />
            <line x1="4" y1="18" x2="20" y2="18" />
        </svg>
    </div>
    <div class="toggle-receiver-header header-mobile-row-invisible">
        <a href="/">Blog</a>
        <a href="/a-propos" class="last-link">A propos</a>
    </div>
    
</header>
      <div class="layout-border">
      
    <div class="article-container">
        <img class="article-image" src="../../assets/blog/GNU-Make-et-le-developpement-logiciel/Makefile-main.png" alt="" />

        <div class="article-intro">
            <p class="article-date">26 MAI 2024 | TECH, MAKEFILE, DEVOPS</p>
            <h1 class="article-title">Make(file) dans le processus de développement logiciel</h1>
            <p class="article-description">Make est un outil permettant de réaliser diverses tâches via l&#39;appel d&#39;une commande. Cet article est un guide sur GNU Make, expliquant comment l&#39;utiliser, ce qu&#39;il apporte et quelles sont ses alternatives.</p>
        </div>
        
        <div class="article-content">
            <h2 id="table-des-mati%C3%A8res" tabindex="-1">Table des matières</h2>
<ul>
<li><a href="#presentation">Présentation</a></li>
<li><a href="#exemple-un-creer-un-fichier-le-remplir-et-le-supprimer">Exemple 1 : Créer un fichier, le remplir et le supprimer</a></li>
<li><a href="#variables">Variables</a>
<ul>
<li><a href="#passer-une-nouvelle-valeur">Passer une nouvelle valeur</a></li>
<li><a href="#variable-d-environnement">Variable d’environnement</a></li>
<li><a href="#variable-referencee">Variable référencée</a></li>
<li><a href="#fichier-de-variable-d-environnement">Fichier de variable d’environnement</a></li>
</ul>
</li>
<li><a href="#cacher-des-instructions-specifiques">Cacher des commandes / instructions spécifiques</a></li>
<li><a href="#les-variables-et-cibles-speciales">Les variables et cibles spéciales</a>
<ul>
<li><a href="#cible-phony">Cible .PHONY</a></li>
<li><a href="#autre-cibles-et-variables-speciales">Autres cibles et variables spéciales</a></li>
</ul>
</li>
<li><a href="#exemple-deux-build-scan-et-push-une-image-docker">Exemple 2 : Build, Scan et Push une image Docker</a></li>
<li><a href="#condition">Condition</a>
<ul>
<li><a href="#egal-ou-pas-egal">Egal ou pas égal</a></li>
<li><a href="#vide-ou-non-vide">Vide ou non vide</a></li>
</ul>
</li>
<li><a href="#vide-ou-non-vide">C’est quoi l’avantage d’un Makefile par rapport à un script</a>
<ul>
<li><a href="#abstraction-et-uniformisation">Abstraction et uniformisation</a></li>
<li><a href="#portabilite">Portabilité</a></li>
</ul>
</li>
<li><a href="#task-et-just">Task(file) et Just(file)</a></li>
<li><a href="#plus-d-informations">Pour plus d’informations</a></li>
</ul>
<h2 id="presentation" tabindex="-1">Présentation</h2>
<p>Un Makefile est un fichier utilisé dans le développement de logiciels pour spécifier les étapes nécessaires à la compilation et à la construction d'un projet. Associé à la commande GNU make, il a été créé dans les années 70 pour automatiser le processus de compilation des projets C et C++. Son utilisation s'étend aujourd'hui à divers langages de programmation et environnements de développement.</p>
<p>Un Makefile est composé de <strong>cibles</strong>. Chaque cible est définie par un nom et peut inclure <strong>une ou plusieurs commandes</strong> à exécuter. Une cible peut également avoir aucun à plusieurs <strong>prérequis</strong> (d'autres cibles) qui seront exécutés avant le lancement de la cible.</p>
<p>La structure d'un fichier Makefile est simple :</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token target symbol">Cible</span><span class="token punctuation">:</span> prérequis
    commande 1
    commande 2
    …</code></pre>
<h2 id="exemple-un-creer-un-fichier-le-remplir-et-le-supprimer" tabindex="-1">Exemple 1 : Créer un fichier, le remplir et le supprimer</h2>
<p>Prenons un exemple simple pour illustrer le fonctionnement d'un Makefile. Nous allons créer un fichier Makefile vide auquel nous ajouterons deux cibles :</p>
<p><strong>create</strong> : Cette cible créera un fichier nommé &quot;file&quot; et y ajoutera le texte &quot;Quel beau fichier&quot;.</p>
<p><strong>delete</strong> : Cette cible supprimera le fichier &quot;file&quot;.</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token target symbol">create</span><span class="token punctuation">:</span>
    touch file
    echo <span class="token string">"Quel beau fichier"</span> > file

<span class="token target symbol">delete</span><span class="token punctuation">:</span>
    rm -f file</code></pre>
<p>Pour exécuter la cible <strong>create</strong>, on utilise la commande <code>make create</code>, et pour exécuter la cible <strong>delete</strong>, on utilise la commande <code>make delete</code>.</p>
<pre class="language-bash"><code class="language-bash"><span class="token comment"># On exécute la cible "create".</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> create
<span class="token function">touch</span> <span class="token function">file</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Quel beau fichier"</span> <span class="token operator">></span> <span class="token function">file</span>

<span class="token comment"># On vérifie que le fichier est bien créé, ainsi que son contenu.</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">ls</span>
Makefile  <span class="token function">file</span>

bast@DESKTOP-97VIG3H:~$ <span class="token function">cat</span> <span class="token function">file</span>
Quel beau fichier

<span class="token comment"># On exécute la cible "delete".</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> delete
<span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token function">file</span>

<span class="token comment"># On vérifie que le fichier est bien supprimé.</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">ls</span>
Makefile</code></pre>
<blockquote>
<p><strong>Note :</strong></p>
<p>Par défaut, make, et par extension le Makefile, affiche les commandes / instructions de la cible pendant son exécution.</p>
</blockquote>
<h2 id="variables" tabindex="-1">Variables</h2>
<p>Et si on complexifie un peu cet exemple, en ajoutant une variable, qui représentera le nom du fichier.</p>
<pre class="language-makefile"><code class="language-makefile">FILENAME<span class="token operator">=</span>file

<span class="token target symbol">create</span><span class="token punctuation">:</span>
    touch <span class="token variable">$</span><span class="token punctuation">(</span>FILENAME<span class="token punctuation">)</span>

<span class="token target symbol">delete</span><span class="token punctuation">:</span>
    rm -f <span class="token variable">$</span><span class="token punctuation">(</span>FILENAME<span class="token punctuation">)</span></code></pre>
<p>Le résultat reste le même, mais nous pouvons maintenant facilement changer le fichier que nous créons ou supprimons en modifiant la valeur de la variable.</p>
<p>Il y a plusieurs façons de modifier le contenu de la variable.</p>
<h3 id="passer-une-nouvelle-valeur">Passer une nouvelle valeur</h3>
<p>On peut passer une valeur en tant qu'argument à l'exécution de la cible  :</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">make</span> create <span class="token assign-left variable">FILENAME</span><span class="token operator">=</span>”second file”</code></pre>
<h3 id="variable-d-environnement">Variable d’environnement</h3>
<p>On peut utiliser une variable d’environnement, il faudra cependant ne pas définir la variable dans le Makefile.</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token target symbol">create</span><span class="token punctuation">:</span>
    touch <span class="token variable">$</span><span class="token punctuation">(</span>FILENAME<span class="token punctuation">)</span>

<span class="token target symbol">delete</span><span class="token punctuation">:</span>
    rm -f <span class="token variable">$</span><span class="token punctuation">(</span>FILENAME<span class="token punctuation">)</span>

FILENAME<span class="token operator">=</span>”second file” make create</code></pre>
<h3 id="variable-referencee">Variable référencée</h3>
<p>Une variable peut en référencer une autre, qui elle-même peut en référencer une autre et ainsi de suite, prenons l’exemple suivant.</p>
<pre class="language-makefile"><code class="language-makefile">FULLNAME<span class="token operator">=</span><span class="token string">"$(FULL) :D"</span>
FULL<span class="token operator">=</span><span class="token string">"$(FIRSTNAME) $(LASTNAME)"</span>
FIRSTNAME<span class="token operator">=</span><span class="token string">"Bastien"</span>
LASTNAME<span class="token operator">=</span><span class="token string">"BYRA"</span>

<span class="token target symbol">echo</span><span class="token punctuation">:</span>
        echo <span class="token variable">$</span><span class="token punctuation">(</span>FULLNAME<span class="token punctuation">)</span></code></pre>
<p>Nous avons deux variables, FIRSTNAME et LASTNAME qui sont définies avec un prénom et un nom.</p>
<p>FULL est une variable qui concatène les deux, donnant le résultat &quot;Bastien BYRA&quot;.</p>
<p>FULLNAME est une variable qui ajoute un smiley à la fin, donnant le résultat &quot;Bastien BYRA :D&quot;.</p>
<pre class="language-bash"><code class="language-bash">bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> <span class="token builtin class-name">echo</span>
<span class="token builtin class-name">echo</span> <span class="token string">""</span>"Bastien<span class="token string">" "</span>BYRA<span class="token string">""</span> :D"
Bastien BYRA :D</code></pre>
<h3 id="fichier-de-variable-d-environnement">Fichier de variable d’environnement</h3>
<p>Pour finir, nous pouvons aussi utiliser les variables d’un fichier d'environnement (.env) en l’incluant dans le Makefile avec la directive &quot;include&quot;.</p>
<p>Contenu du fichier .env :</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token target symbol">bast@DESKTOP-97VIG3H</span><span class="token punctuation">:</span>~$ cat .env
FULLNAME<span class="token operator">=</span>SOMEONE</code></pre>
<p>Contenu du fichier Makefile :</p>
<pre class="language-makefile"><code class="language-makefile">FULLNAME<span class="token operator">=</span><span class="token string">"$(FULL) :D"</span>
FULL<span class="token operator">=</span><span class="token string">"$(FIRSTNAME) $(LASTNAME)"</span>
FIRSTNAME<span class="token operator">=</span><span class="token string">"Bastien"</span>
LASTNAME<span class="token operator">=</span><span class="token string">"BYRA"</span>

<span class="token keyword">include</span> .env

<span class="token target symbol">echo</span><span class="token punctuation">:</span>
        echo <span class="token variable">$</span><span class="token punctuation">(</span>FULLNAME<span class="token punctuation">)</span></code></pre>
<p>Le résultat :</p>
<pre class="language-bash"><code class="language-bash">bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> <span class="token builtin class-name">echo</span>
<span class="token builtin class-name">echo</span> SOMEONE
SOMEONE</code></pre>
<blockquote>
<p><strong>Note :</strong></p>
<p>La valeur FULLNAME de mon fichier d’environnement a surchargé la valeur FULLNAME définie dans mon Makefile, mais c’est uniquement le cas car j’ai mis la directive &quot;include&quot; après la définition de ma variable FULLNAME.<br>
Si j’ajoute la directive &quot;include&quot; au début de mon fichier, la valeur de FULLNAME sera “Bastien BYRA :D”.</p>
</blockquote>
<h2 id="cacher-des-instructions-specifiques" tabindex="-1">Cacher des commandes / instructions spécifiques</h2>
<p>Par défaut, un Makefile va afficher les instructions exécutées au fur et à mesure de son exécution, nous pouvons le voir à l’appel de notre commande <code>echo $(FULLNAME)</code> qui renvoie <code>echo &quot;&quot;&quot;Bastien&quot; &quot;BYRA&quot;&quot; :D&quot;</code>.</p>
<p>Pour éviter ça, on peut ajouter le caractère <code>@</code> devant la ligne dont on ne veut pas afficher l’instruction.</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token target symbol">echo</span><span class="token punctuation">:</span>
        <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>FULLNAME<span class="token punctuation">)</span></code></pre>
<p>Quand on exécute “make echo” :</p>
<pre class="language-bash"><code class="language-bash">bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> <span class="token builtin class-name">echo</span>
Bastien BYRA :D</code></pre>
<h2 id="les-variables-et-cibles-speciales" tabindex="-1">Les variables et cibles spéciales</h2>
<p>Les fichiers Makefile ont un ensemble de <a href="https://www.gnu.org/software/make/manual/html_node/Special-Variables.html" target="_blank">variables spéciales</a> et <a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html" target="_blank">cibles spéciales</a> prédéfinies.</p>
<p>Elles sont toutes définies de la même manière : .&lt;NOM_EN_MAJUSCULE&gt;</p>
<p>Parmi les différentes cibles spéciales existantes, l'une est essentielle à connaître.</p>
<h3 id="cible-phony">Cible .PHONY</h3>
<p>Pour comprendre le but de <code>.PHONY</code>, il faut remettre en contexte le but du Makefile : à l’origine, le Makefile était conçu pour automatiser la compilation de projets (en C, par exemple). Les cibles pouvaient porter le même nom que le fichier qu'elles compilaient, servant ainsi de vérification pour le Makefile.</p>
<p>Si un fichier du même nom que la cible existe, alors la commande ne s’exécute pas, car tout est jugé comme étant en ordre. Pour montrer concrètement, prenons l’exemple de &quot;create&quot;.</p>
<p>Si nous n’avons pas de fichier nommé ‘create” à la racine du projet (là ou nous avons notre fichier Makefile), il n’y aura aucun problème d’exécution de la cible.</p>
<pre class="language-bash"><code class="language-bash"><span class="token comment"># Le contenu de mon Makefile</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">cat</span> Makefile
create:
        @touch <span class="token variable"><span class="token variable">$(</span>FILENAME<span class="token variable">)</span></span>

<span class="token comment"># On crée un fichier "create"</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> create <span class="token assign-left variable">FILENAME</span><span class="token operator">=</span><span class="token string">"create"</span>

<span class="token comment"># On constate qu'un fichier "create" existe maintenant</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">ls</span>
Makefile  create</code></pre>
<p>Nous avons créé un fichier “create”, maintenant refaisons exactement la même commande.</p>
<pre class="language-bash"><code class="language-bash">bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> create <span class="token assign-left variable">FILENAME</span><span class="token operator">=</span><span class="token string">"create"</span>
make: <span class="token string">'create'</span> is up to date.</code></pre>
<p>C’est problématique car il nous empêche d'exécuter notre cible “create”. Comment résoudre ce problème ?</p>
<p>Pour ce faire, on utilise la cible spéciale <code>.PHONY</code> qui permet d’indiquer que la cible ne doit pas se soucier de l'existance d'un fichier du même nom dans le répertoire.</p>
<p>Pour ajouter des cibles à la cible spéciale <code>.PHONY</code>. Il y a deux moyens de le faire.</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> create delete</code></pre>
<p>ou</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> create
<span class="token target symbol">create</span><span class="token punctuation">:</span>
    touch <span class="token variable">$</span><span class="token punctuation">(</span>FILENAME<span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> delete
<span class="token target symbol">delete</span><span class="token punctuation">:</span>
    rm -f <span class="token variable">$</span><span class="token punctuation">(</span>FILENAME<span class="token punctuation">)</span></code></pre>
<h3 id="autre-cibles-et-variables-speciales">Autres cibles et variables spéciales</h3>
<p>Il existe d'autres cibles et variables spéciales qui peuvent valoir le détour :</p>
<ul>
<li><strong>.DEFAULT_GOAL</strong> : Par défaut, si on exécute <code>make</code> sans spécifier de cible, la première cible est exécutée, <code>.DEFAULT_GOAL</code> permet de définir la cible à lancer par défaut si aucune cible n'est indiquée.</li>
<li><strong>.SILENT</strong> : Par défaut, les cibles renvoient des résultats. Un <code>docker pull</code> ou <code>docker build</code> renvoie beaucoup de lignes, <code>.SILENT</code> permet de dire à une ou plusieurs cibles de ne rien envoyer à l'utilisateur.</li>
</ul>
<p>Je vous invite à regarder les cibles et variables spéciales disponibles en fonction de vos besoins.</p>
<h2 id="exemple-deux-build-scan-et-push-une-image-docker" tabindex="-1">Exemple 2 : Build, Scan et Push une image Docker</h2>
<p>Pour donner un exemple concret utilisant les concepts abordés, voici un fichier Makefile permettant de réaliser les actions suivantes :</p>
<ul>
<li><strong>Build</strong> une image Docker</li>
<li><strong>Scan</strong> sur l'image Docker, en appelant la fonction de Build au préalable</li>
<li><strong>Push</strong> l'image Docker</li>
<li><strong>Run</strong> une image Docker, en appelant la fonction de Build au préalable</li>
</ul>
<p>Le tout en utilisant des variables afin de rendre le fichier plus flexible et portable, ainsi que la cible spéciale <code>.DEFAULT_GOAL</code>.</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token builtin-target builtin">.DEFAULT_GOAL</span><span class="token punctuation">:</span> run

DOCKERHUB_NAME <span class="token operator">=</span> mon_nom
IMAGE_NAME <span class="token operator">=</span> mon_image

<span class="token target symbol">build</span><span class="token punctuation">:</span>
    docker build -t <span class="token variable">$</span><span class="token punctuation">(</span>IMAGE_NAME<span class="token punctuation">)</span> .

<span class="token target symbol">scan</span><span class="token punctuation">:</span> build
    docker scout quickview <span class="token variable">$</span><span class="token punctuation">(</span>IMAGE_NAME<span class="token punctuation">)</span>

<span class="token target symbol">push</span><span class="token punctuation">:</span>
<span class="token target symbol">    docker tag <span class="token variable">$</span>(IMAGE_NAME) <span class="token variable">$</span>(DOCKERHUB_NAME)/<span class="token variable">$</span>(IMAGE_NAME)</span><span class="token punctuation">:</span>latest
<span class="token target symbol">    docker push <span class="token variable">$</span>(DOCKERHUB_NAME)/<span class="token variable">$</span>(IMAGE_NAME)</span><span class="token punctuation">:</span>latest

<span class="token target symbol">run</span><span class="token punctuation">:</span> build
    docker run -d <span class="token variable">$</span><span class="token punctuation">(</span>IMAGE_NAME<span class="token punctuation">)</span></code></pre>
<p>Nous avons un fichier Makefile, qui déclare 4 cibles (<code>build</code>, <code>scan</code>, <code>push</code> et <code>run</code>), deux variables (<code>DOCKERHUB_NAME</code> et <code>IMAGE_NAME</code>) et une cible spéciale <code>.DEFAULT_GOAL</code></p>
<p>Pour exécuter les tâches, il suffit d'appeler la commande <code>make</code> avec le nom de la cible :</p>
<p><code>make build</code> va générer une image Docker de notre application selon un Dockerfile spécifié à la racine du projet.<br>
<code>make scan</code> va appelé <code>make build</code>, puis exécuter un scan de l’image Docker.<br>
<code>make push</code> va pousser l’image dans la registry Docker.<br>
<code>make run</code> va appelé <code>make build</code>, puis lancer l’image sur la machine local.</p>
<h2 id="condition" tabindex="-1">Condition</h2>
<p>Les Makefiles permettent de mettre en place des conditions ;</p>
<h3 id="egal-ou-pas-egal">Egal ou pas égal</h3>
<p>ifreq : Vérifie si les deux arguments sont égaux</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token target symbol">cond</span><span class="token punctuation">:</span>
<span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>, <span class="token string">"True"</span><span class="token punctuation">)</span>
        echo <span class="token string">"True !"</span>
<span class="token keyword">else</span>
        echo <span class="token string">"False D:"</span>
<span class="token keyword">endif</span></code></pre>
<p>Dans cet exemple, si BOOL est égal à “True”, alors il renvoie “True !”, autrement il renvoie “False D:”</p>
<p>ifneq : Vérifie si deux arguments ne sont pas égaux.</p>
<pre class="language-makefile"><code class="language-makefile"><span class="token target symbol">cond</span><span class="token punctuation">:</span>
<span class="token keyword">ifneq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>, <span class="token string">"True"</span><span class="token punctuation">)</span>
        echo <span class="token string">"True !"</span>
<span class="token keyword">else</span>
        echo <span class="token string">"False D:"</span>
<span class="token keyword">endif</span></code></pre>
<p>Dans cet exemple, si BOOL est égal à “True”, alors il renvoie “False D:”, autrement il renvoie “True !”</p>
<h3 id="vide-ou-non-vide">Vide ou non vide</h3>
<p>ifdef : Vérifie si la variable passée en paramètre possède une valeur.</p>
<pre class="language-bash"><code class="language-bash">bast@DESKTOP-97VIG3H:~$ <span class="token function">cat</span> Makefile
cond:
ifdef VALUE
        @echo <span class="token variable"><span class="token variable">$(</span>VALUE<span class="token variable">)</span></span>
<span class="token keyword">else</span>
        @echo <span class="token string">"La variable est vide !"</span>
endif
bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> cond
La variable est vide <span class="token operator">!</span>

bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> cond <span class="token assign-left variable">VALUE</span><span class="token operator">=</span><span class="token string">"Une valeur !"</span>
Une valeur <span class="token operator">!</span>

bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> cond <span class="token assign-left variable">VALUE</span><span class="token operator">=</span><span class="token string">""</span>
La variable est vide <span class="token operator">!</span>
bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> cond <span class="token assign-left variable">VALUE</span><span class="token operator">=</span><span class="token string">" "</span>
La variable est vide <span class="token operator">!</span></code></pre>
<p>ifndef : Vérifie si la variable passée en paramètre ne possède pas de valeur.</p>
<pre class="language-bash"><code class="language-bash">bast@DESKTOP-97VIG3H:~$ <span class="token function">cat</span> Makefile
cond:
ifndef VALUE
        @echo <span class="token string">"La variable est vide !"</span>
<span class="token keyword">else</span>
        @echo <span class="token string">"La variable n'est pas vide : <span class="token variable"><span class="token variable">$(</span>VALUE<span class="token variable">)</span></span>"</span>
endif

bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> cond <span class="token assign-left variable">VALUE</span><span class="token operator">=</span><span class="token string">"  "</span>
La variable est vide <span class="token operator">!</span>

bast@DESKTOP-97VIG3H:~$ <span class="token function">make</span> cond <span class="token assign-left variable">VALUE</span><span class="token operator">=</span><span class="token string">"  am    i        empty  ?"</span>
La variable n'est pas vide <span class="token builtin class-name">:</span> am    i        empty  ?</code></pre>
<h2 id="vide-ou-non-vide" tabindex="-1">C’est quoi l’avantage d’un Makefile par rapport à un script</h2>
<p>C’est une question légitime, et la réponse que je vais vous donner est plutôt simple ;</p>
<h3 id="abstraction-et-uniformisation">Abstraction et uniformisation</h3>
<p>Le Makefile permet de faire office d’abstraction, en permettant à nos utilisateurs/équipes d'exécuter ce qui aurait été normalement plusieurs scripts en utilisant la commande make. Ainsi, tout notre processus est réuni dans un unique fichier.</p>
<p>De plus, ce fichier permet d’uniformiser les différents processus pour ceux qui les utilisent. Par exemple, que ce soit un projet en JavaScript, Java, Python ou Go, le développeur n’aura qu’à faire make run pour lancer son projet, indépendamment des technologies utilisées.</p>
<h3 id="portabilite">Portabilité</h3>
<p>Au lieu d’avoir une myriade de scripts par projet, vous n’avez qu’un Makefile par projet à entretenir (ou plusieurs Makefile par projet, mais vous aurez toujours moins de Makefiles qu’il n’y aurait eu de scripts).</p>
<p>Avoir plusieurs scripts peut être nécessaire, notamment si la tâche qu’ils exécutent est complexe, mais si les scripts sont relativement courts et simples, tout réunir dans un seul et unique fichier peut valoir le coup. Cela dépendra de chaque situation.</p>
<h2 id="task-et-just" tabindex="-1">Task(file) et Just(file)</h2>
<p>Make, et donc le Makefile par extension, existe depuis longtemps, bien plus longtemps que moi ! Et comme moi, des gens aiment GNU make et sa proposition.</p>
<p>Le problème avec make, c’est qu’il a été créé avec pour but premier la compilation de code C et C++. Il est un produit qui répond à un besoin spécifique, certes il est suffisamment flexible pour répondre à d'autres besoins, mais il demande des adaptations.</p>
<p>Là où je veux en venir, c’est qu'au fil du temps, différentes solutions ont été créées, partant de make pour proposer quelque chose qui correspond plus à nos besoins. Parmi ces alternatives, on trouve Just et Task, deux alternatives populaires à make.</p>
<p>Je n’entre pas dans les détails de <code>Task</code> et <code>Just</code>, mais si vous recherchez une solution similaire à Make mais pensée pour être plus simple et facile à configurer/utiliser, incluant des fonctionnalités pratiques (lecture des fichiers .env, pas besoin de spécifier les cibles en .PHONY, possibilité de lister les cibles définies et leur description…), ils peuvent être une alternative intéressante. Cependant, contrairement à make, qui est disponible presque partout, il vous faudra les installer au préalable.</p>
<ul>
<li>Just : <a href="https://just.systems/man/en/chapter_1.html" target="_blank">https://just.systems/man/en/chapter_1.html</a></li>
<li>Task : <a href="https://taskfile.dev/" target="_blank">https://taskfile.dev/</a></li>
</ul>
<blockquote>
<p><strong>Note :</strong></p>
<p>Just utilise la même syntaxe que Make, là où Task est configuré en utilisant du YAML.</p>
</blockquote>
<h2 id="plus-d-informations" tabindex="-1">Pour plus d’informations :</h2>
<ul>
<li>Site officiel de “make” : <a href="https://www.gnu.org/software/make/manual/make.html" target="_blank">Site officiel de “make”</a></li>
<li>GNU make for DevOps engineers : <a href="https://alexharv074.github.io/2019/12/26/gnu-make-for-devops-engineers.html" target="_blank">&quot;GNU make for DevOps engineers&quot; de Alex Harvey</a></li>
<li>Exemple de Makefile dans le monde réel (GraphQL Python) : <a href="https://github.com/graphql-python/graphene/blob/master/docs/Makefile" target="_blank">Exemple de Makefile dans le monde réel (GraphQL Python)</a></li>
<li>Exemple de Makefile dans le monde réel (NGINX) : <a href="https://hg.nginx.org/pkg-oss/file/tip/Makefile" target="_blank">Exemple de Makefile dans le monde réel (NGINX)</a></li>
</ul>

        </div>

        <hr>
        
        <div class="article-end">
            <p>Merci d'avoir lu cet article, n'hésitez pas à jeter un coup d'oeil aux autres articles.</p>
            <a class="link-to-articles" href="https://bastienbyra.fr/">Mes autres articles.</a>
            <div class="article-social-network">
                <p>par <span class="blueviolet">Bastien BYRA</span></p>
                <div class="article-network-image">
                    <a href="https://github.com/BastienBYRA">
                        <img src="/assets/social_network/Github.png" alt="Logo de Github" />
                    </a>
                    <a href="https://www.linkedin.com/in/bastien-byra-848998209/">
                        <img src="/assets/social_network/Linkedin.png" alt="Logo de Linkedin" />
                    </a>
                </div>
            </div>
        </div>
    </div>

      </div>
    </div>
  </body>
</html>